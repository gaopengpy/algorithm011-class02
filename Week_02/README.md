HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。

JDK1.7中 HashMap是数组+链表的数据结构，JDK1.8中HashMap是数组+链表+红黑树的数据结构，JDK1.8的HashMap链表的长度超过8会转换成红黑树。

HashMap的存取过程，当执行putVal的操作的时候，

1.首先检查大小，看是否需要扩容（默认元素超过最大值的0.75时扩容），如果需要扩容就进行扩容

2.然后计算出key的hashcode，根据hashcode定位数值所在的bucketIndex

3.如果该位置上没有元素，就直接插入，结束

4.如果该位置上有元素就使用equal比较是否相同

5.如果key相同就把新的value替换旧的value,结束

6.如果key不同，就继续遍历，找到根节点，如果没找到key的话，就构造一个新的节点，然后把节点插入到链表尾部，表示put成功（jdk 1.8 之后链表长度超过阈值就会转化为红黑树）

HashMap扩容大小为什么是2的幂?

理想的状况，hashMap的存取就是O（1），也就是直接根据hashcode就可以找到它，每个bucket只存储一个节点，链表指向都是null,这样就比较开心了，不要出现一个链表很长的情况。

所以我们希望它能分布的均匀一点，如果让我们设计的话，我们肯定是直接对长度取模-----hashcode % length,但HashMap的设计者却不是这样写的，它写成了2进制运算，如下：

 static final int hash(Object key) {
     int h;
     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
 }
 
数组的具体存取规则是tab[(n-1) & hash]，其中tab为node数组，n为数组的长度，hash为key的hash值。

为什么设计成(n - 1) & hash 这样呢？在 n 为 2次幂的情况下时，(n - 1) & hash ≈ hash % n ,因为2进制的运算速度远远高于取模，所以就使用了这种方式，所以要求为2的幂。

我们可以看到它求hash的过程，将32位的hashCode值向左移动16位，高位补0，也就是只要了高16位，这是为什么呢？因为hashcode的计算方法导致哈希值的差异主要在高位，而 (n - 1) & hash是忽略了容量以上的高位的，所以 使用h >>>16就是为了避免类似情况的哈希冲突。

HashMap为什么是线程不安全的？

HashMap默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为<原下标+原容量>的位置。

重新调整HashMap大小存在什么问题吗？

当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）
为什么多线程会导致死循环，它是怎么发生的？
HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。

1.扩容：创建一个新的Entry空数组，长度是原数组的2倍。

2.ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。

总结

HashMap是线程不安全的，其主要体现：

1.在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。
2.在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。
